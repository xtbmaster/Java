package sample;

import sample.dotLines.PointConnector;
import sample.dotLines.Point;
import sample.crypting.compilePck.*;

import java.lang.*;
import java.util.Set;

public class sampleTesting {

    public static void main(String[] args) {

        /**
         *                              TASK 1 TEST
         *
         * Необходимо вычислить квадратный корень заданного натурального числа n с
         округлением вниз до ближайшего целого, не используя функций sqrt(n) и n^0.5. Например,
         для числа 14 результатом будет число 3, для числа 28 – число 5. Также необходимо
         привести краткую информацию об используемом алгоритме.

         Входные данные
         Произвольное натуральное число n.

         Выходные данные
         Квадратный корень заданного числа, округлённый вниз до ближайшего целого.
         */

        System.out.println("TASK 1 TEST");

        System.out.println(SqrRoot.sqrRoot(-9, 0.0001));
        System.out.println();

        //

        /**
         *                              TASK 2 TEST
         *
         * Задан массив, элементами которого являются произвольные целые числа. Необходимо
         определить (максимально оптимальным образом) элемент с индексом k для массива,
         состоящего из таких же чисел, но отсортированного по возрастанию. Например, для
         массива [6, 1, 4, 1, 7] и k=3 правильным ответом будет число 4 ([1, 1, 4, 6, 7]).

         Входные данные
         Массив произвольных целых чисел и натуральное число k (1 <= k <= длина массива).

         Выходные данные
         k­й элемент массива, состоящего из таких же чисел, как и исходный массив, но
         отсортированного по возрастанию.
         */

        System.out.println("TASK 2 TEST");

        int index = 1;
        System.out.println(ArraySearch.indexSearch(new int[]{6, 1, 4, 1, 7}, index));
        System.out.println();

        //                      TASK 3 TEST

        /**
         *  На вход приложения подается список строк­шифров, заданных в определенном формате
         и содержащих информацию о запланированных грузоперевозках. Программа должна
         произвести дешифровку списка входящих строк­шифров и сохранить результирующие
         данные в CSV файл в виде таблицы, используя следующие указания и алгоритм расшифровки:

        1 шифр (строка) исходный шифр

        2 код водителя (строка) значение присутствует всегда, представляет собой
        первые 4 символа строки шифра

        3 код путевого листа (строка) значение присутствует всегда, имеет следующий
        формат (по порядку, слева направо):
            ○ символ «R» или «r»
            ○ код опасного груза «d» (опционально)
            ○ код хрупкого груза «f» (опционально)
            ○ номер путевого листа, который при наличии кода хрупкого и/или опасного груза
         состоит из 3х цифр, а при отсутствии обоих – из 4х
            ○ код водителя (опционален, при наличии является идентичным коду водителя,
        расшифрованному в столбце №2)

        4 опасный («true» или «false») см. «код путевого листа» для дешифровки; при
        наличии кода в шифре следует сохранить в поле таблицы значение «true»,
         при отсутствии ­ «false»

        5 хрупкий («true» или «false») см. «код путевого листа» для дешифровки; при
        наличии кода в шифре следует сохранить в поле таблицы значение «true»,
         при отсутствии ­ «false»

        6 температура (число) является опциональным значением; при наличии
        состоит из 4 символов и имеет следующий формат:
            ○ первый символ – знак «+» или «­»
            ○ остальные символы – строка из цифр, задающих значение температуры;
         может иметь префикс из нулей

         7 наименование (строка) значение присутствует всегда; представляет собой
         последовательность символов из таблицы, закодированную в виде цифр
         в восьмеричной системе счисления; при этом, ASCII­код каждого символа
         результирующей строки представлен в заданной последовательности тремя
         цифрами. Например, "water" <­> "167141164145162"

         Также известно, что:
            ○ все блоки информации, если они присутствуют в шифре, всегда расположены по
         отношению друг к другу в указанном в таблице порядке. Исключением являются
         поля №4 и №5, которые входят в состав кода путевого листа, однако при этом всё
         равно сохраняют заданный порядок по отношению друг к другу
            ○ после блоков №2 и №7 может присутствовать до двух (включительно) незначащих
         алфавитно­цифровых символов (латиница)

         Входные данные
         Список строк­шифров

         Выходные данные
         CSV файл, содержащий таблицу с дешифрованными данными

         */

        System.out.println("TASK 3 TEST");

        String[] cipherArray = new String[]{
                "RMuiRdf010160141151156164",
                "lims8r3860lims1631411561441",
                "GZQRyr6870GZQR+0041431501451451631455A",
                "qkMfPjrd0561411551551651561511641511571567",
                "EOcTkerf389-0201511431450551431621451411550"};

        Set<String> set = CodeCompiler.getUncryptedList(cipherArray);
        set.forEach(System.out::println);
        System.out.println();

        //

        /**
         *                              TASK 4 TEST
         *
         * Заданы n произвольных точек на плоскости. Необходимо объединить все имеющиеся
         точки замкнутой ломаной линией таким образом, чтобы она не имела самопересечений.

         Входные данные
         Список произвольных координат точек на плоскости.

         Выходные данные
         Список координат точек на плоскости, которые при последовательном соединении
         образуют замкнутую ломаную линию, не имеющую самопересечений.
         */

        System.out.println("TASK 4 TEST");
        
        PointConnector pCon = new PointConnector(
                new Point[]{
            new Point(1.0, 2.6),
            new Point(9.7, -6.2),
            new Point(3.6, -9.5),
            new Point(4.0, 2.4),
            new Point(-1.0, 2.6)});

        pCon.display(pCon.notCrossingConnect());
        System.out.println();
    }
}
